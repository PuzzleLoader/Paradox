--- a/finalforeach/cosmicreach/savelib/crbin/CRBinDeserializer.java
+++ b/finalforeach/cosmicreach/savelib/crbin/CRBinDeserializer.java
@@ -1,5 +_,13 @@
 package finalforeach.cosmicreach.savelib.crbin;
 
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.nio.ByteBuffer;
+import java.util.Base64;
+import java.util.function.BiFunction;
+import java.util.function.IntFunction;
+import java.util.function.ObjIntConsumer;
+
 import finalforeach.cosmicreach.savelib.utils.ByteArrayUtils;
 import finalforeach.cosmicreach.savelib.utils.DynamicArrays;
 import finalforeach.cosmicreach.savelib.utils.IDynamicArray;
@@ -8,18 +_,14 @@
 import finalforeach.cosmicreach.savelib.utils.IObjectLongMap;
 import finalforeach.cosmicreach.savelib.utils.IObjectMap;
 import finalforeach.cosmicreach.savelib.utils.ObjectMaps;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.nio.ByteBuffer;
-import java.util.Base64;
-import java.util.function.BiFunction;
-import java.util.function.IntFunction;
-import java.util.function.ObjIntConsumer;
-
-public class CRBinDeserializer {
-	private static final IObjectMap<Class<?>, BiFunction<String, CRBinDeserializer, ?>> defaultClassDeserializers = ObjectMaps.getNew();
-	private IObjectMap<Class<?>, BiFunction<String, CRBinDeserializer, ?>> classDeserializers = defaultClassDeserializers;
+
+public class CRBinDeserializer
+{
+	private static final IObjectMap<Class<?>, BiFunction<String, CRBinDeserializer, ?>> 
+		defaultClassDeserializers = ObjectMaps.getNew();
+	private IObjectMap<Class<?>, BiFunction<String, CRBinDeserializer, ?>> classDeserializers 
+	= defaultClassDeserializers;
+
 	private CRBinSchema schema;
 	private IDynamicArray<CRBinSchema> altSchemas;
 	private IDynamicArray<String> strings;
@@ -29,321 +_,407 @@
 	private IObjectMap<String, Double> doubleValues = ObjectMaps.getNew();
 	private IObjectMap<String, Object> objValues = ObjectMaps.getNew();
 
-	public static CRBinDeserializer getNew() {
+
+	public static CRBinDeserializer getNew() 
+	{
 		return new CRBinDeserializer();
 	}
 
-	public static CRBinDeserializer fromBase64(String base64) {
-		CRBinDeserializer crbindeserializer = getNew();
-		ByteBuffer bytebuffer = ByteBuffer.wrap(Base64.getDecoder().decode(base64));
-		crbindeserializer.prepareForRead(bytebuffer);
-		return crbindeserializer;
+	public static CRBinDeserializer fromBase64(String base64) 
+	{
+		CRBinDeserializer deserial = CRBinDeserializer.getNew();
+		var byteBuf = ByteBuffer.wrap(Base64.getDecoder().decode(base64));
+		deserial.prepareForRead(byteBuf);
+		return deserial;
 	}
 
-	public static boolean isThereDefaultClassDeserializer(Class<?> clazz) {
+	
+	public static boolean isThereDefaultClassDeserializer(Class<?> clazz) 
+	{
 		return defaultClassDeserializers.containsKey(clazz);
 	}
 
-	public static <T> void registerDefaultClassDeserializer(Class<T> clazz, BiFunction<String, CRBinDeserializer, T> func) {
-		synchronized (defaultClassDeserializers) {
-			if (isThereDefaultClassDeserializer(clazz)) {
+	public static <T> void registerDefaultClassDeserializer(Class<T> clazz, BiFunction<String, CRBinDeserializer, T> func) 
+	{
+		synchronized (defaultClassDeserializers) 
+		{
+			if(isThereDefaultClassDeserializer(clazz)) 
+			{
 				throw new RuntimeException("Cannot register a default class deserializer twice!");
-			} else {
-				defaultClassDeserializers.put(clazz, func);
-			}
-		}
-	}
-
-	public <T> void registerClassDeserializer(Class<?> clazz, BiFunction<String, CRBinDeserializer, T> func) {
-		if (this.classDeserializers == defaultClassDeserializers) {
-			this.classDeserializers = ObjectMaps.getNew(defaultClassDeserializers);
-		}
-
-		this.classDeserializers.put(clazz, func);
-	}
-
-	private void readSchema(CRBinSchema schema, ByteBuffer bytes) {
-		boolean flag = false;
-
-		while (bytes.hasRemaining()) {
-			byte b0 = bytes.get();
-			SchemaType schematype = SchemaType.get(b0);
-			if (schematype == SchemaType.SCHEMA_END) {
-				flag = true;
-				break;
-			}
-
-			String s = ByteArrayUtils.readString(bytes);
-			schema.add(s, schematype);
-		}
-
-		if (!flag) {
+			}
+			defaultClassDeserializers.put(clazz, func);	
+		}
+	}
+
+	public <T> void registerClassDeserializer(Class<?> clazz, BiFunction<String, CRBinDeserializer, T> func) 
+	{
+		if(classDeserializers == defaultClassDeserializers) 
+		{
+			classDeserializers = ObjectMaps.getNew(defaultClassDeserializers);
+		}
+		classDeserializers.put(clazz, func);
+	}
+
+	private void readSchema(CRBinSchema schema, ByteBuffer bytes)
+	{
+		boolean validSchema = false;
+		schemaRead:
+			while(bytes.hasRemaining()) 
+			{
+				byte b = bytes.get();
+				var stype = SchemaType.get(b);
+
+				if(stype == SchemaType.SCHEMA_END) 
+				{
+					validSchema = true;
+					break schemaRead;
+				}
+
+				String name = ByteArrayUtils.readString(bytes);
+				schema.add(name, stype);
+			}
+		if(!validSchema) 
+		{
 			throw new RuntimeException("Invalid schema");
 		}
 	}
-
-	private CRBinDeserializer readObj(ByteBuffer bytes) {
-		int i = ByteArrayUtils.readInt(bytes);
-		if (i == -1) {
+	private CRBinDeserializer readObj(ByteBuffer bytes) 
+	{
+		int altSchema = ByteArrayUtils.readInt(bytes);
+		if(altSchema == -1) 
+		{
 			return null;
-		} else {
-			CRBinSchema crbinschema = this.altSchemas.get(i);
-			CRBinDeserializer crbindeserializer = getNew();
-			crbindeserializer.classDeserializers = this.classDeserializers;
-			crbindeserializer.altSchemas = this.altSchemas;
-			crbindeserializer.strings = this.strings;
-			crbindeserializer.readDataFromSchema(crbinschema, bytes);
-			return crbindeserializer;
-		}
-	}
-
-	private void readDataFromSchema(CRBinSchema schema, ByteBuffer bytes) {
-		for (CRBinSchema.SchemaItem crbinschema$schemaitem : schema.getSchema()) {
-			String s = crbinschema$schemaitem.name();
-			switch (crbinschema$schemaitem.type()) {
-				case BOOLEAN:
-				case BYTE:
-					this.intValues.put(s, ByteArrayUtils.readByte(bytes));
-					break;
-				case DOUBLE:
-					this.doubleValues.put(s, ByteArrayUtils.readDouble(bytes));
-					break;
-				case FLOAT:
-					this.floatValues.put(s, ByteArrayUtils.readFloat(bytes));
-					break;
-				case INT:
-					this.intValues.put(s, ByteArrayUtils.readInt(bytes));
-					break;
-				case LONG:
-					this.longValues.put(s, ByteArrayUtils.readLong(bytes));
-					break;
-				case SHORT:
-					this.intValues.put(s, ByteArrayUtils.readShort(bytes));
-					break;
-				case STRING:
-					int j = ByteArrayUtils.readInt(bytes);
-					this.intValues.put(s, j);
-					break;
-				case OBJ:
-					CRBinDeserializer crbindeserializer = this.readObj(bytes);
-					this.objValues.put(s, crbindeserializer);
-					break;
-				case OBJ_ARRAY:
-					int i = ByteArrayUtils.readInt(bytes);
-					CRBinDeserializer[] acrbindeserializer = new CRBinDeserializer[i];
-
-					for (int k = 0; k < i; k++) {
-						acrbindeserializer[k] = this.readObj(bytes);
-					}
-
-					this.objValues.put(s, acrbindeserializer);
-					break;
-				case STRING_ARRAY:
-					this.readArray(bytes, s, String[]::new, (arr, ix) -> arr[ix] = this.strings.get(ByteArrayUtils.readInt(bytes)));
-					break;
-				case BOOLEAN_ARRAY:
-					this.readArray(bytes, s, boolean[]::new, (arr, ix) -> arr[ix] = ByteArrayUtils.readByte(bytes) == 1);
-					break;
-				case BYTE_ARRAY:
-					this.readArray(bytes, s, byte[]::new, (arr, ix) -> arr[ix] = ByteArrayUtils.readByte(bytes));
-					break;
-				case DOUBLE_ARRAY:
-					this.readArray(bytes, s, double[]::new, (arr, ix) -> arr[ix] = ByteArrayUtils.readDouble(bytes));
-					break;
-				case FLOAT_ARRAY:
-					this.readArray(bytes, s, float[]::new, (arr, ix) -> arr[ix] = ByteArrayUtils.readFloat(bytes));
-					break;
-				case INT_ARRAY:
-					this.readArray(bytes, s, int[]::new, (arr, ix) -> arr[ix] = ByteArrayUtils.readInt(bytes));
-					break;
-				case LONG_ARRAY:
-					this.readArray(bytes, s, long[]::new, (arr, ix) -> arr[ix] = ByteArrayUtils.readLong(bytes));
-					break;
-				case SHORT_ARRAY:
-					this.readArray(bytes, s, short[]::new, (arr, ix) -> arr[ix] = ByteArrayUtils.readShort(bytes));
-			}
-		}
-	}
-
-	private <T> void readArray(ByteBuffer bytes, String name, IntFunction<T> arrCreator, ObjIntConsumer<T> perElement) {
-		int i = ByteArrayUtils.readInt(bytes);
-		if (i == -1) {
-			this.objValues.put(name, null);
-		} else {
-			T t = arrCreator.apply(i);
-
-			for (int j = 0; j < i; j++) {
-				perElement.accept(t, j);
-			}
-
-			this.objValues.put(name, t);
-		}
-	}
-
-	public String[] readStringArray(String name) {
-		return (String[])this.objValues.get(name);
-	}
-
-	public boolean[] readBooleanArray(String name) {
-		return (boolean[])this.objValues.get(name);
-	}
-
-	public byte[] readByteArray(String name) {
-		return (byte[])this.objValues.get(name);
-	}
-
-	public short[] readShortArray(String name) {
-		return (short[])this.objValues.get(name);
-	}
-
-	public int[] readIntArray(String name) {
-		return (int[])this.objValues.get(name);
-	}
-
-	public long[] readLongArray(String name) {
-		return (long[])this.objValues.get(name);
-	}
-
-	public float[] readFloatArray(String name) {
-		return (float[])this.objValues.get(name);
-	}
-
-	public double[] readDoubleArray(String name) {
-		return (double[])this.objValues.get(name);
-	}
-
-	public void prepareForRead(ByteBuffer bytes) {
-		this.schema = new CRBinSchema();
-		this.altSchemas = DynamicArrays.getNew(CRBinSchema.class);
-		int i = ByteArrayUtils.readInt(bytes);
-		this.strings = DynamicArrays.getNew(String.class, i);
-
-		for (int j = 0; j < i; j++) {
-			this.strings.add(ByteArrayUtils.readString(bytes));
-		}
-
-		this.readSchema(this.schema, bytes);
-		int l = ByteArrayUtils.readInt(bytes);
-
-		for (int k = 0; k < l; k++) {
-			CRBinSchema crbinschema = new CRBinSchema();
-			this.readSchema(crbinschema, bytes);
-			this.altSchemas.add(crbinschema);
-		}
-
-		this.readDataFromSchema(this.schema, bytes);
-	}
-
-	public int readInt(String name, int defaultValue) {
-		return this.intValues.get(name, defaultValue);
-	}
-
-	public long readLong(String name, long defaultValue) {
-		return this.longValues.get(name, defaultValue);
-	}
-
-	public short readShort(String name, short defaultValue) {
-		return (short)this.intValues.get(name, defaultValue);
-	}
-
-	public float readFloat(String name, float defaultValue) {
-		return this.floatValues.get(name, defaultValue);
-	}
-
-	public boolean readBoolean(String name, boolean defaultValue) {
-		return this.intValues.get(name, defaultValue ? 1 : 0) == 1;
-	}
-
-	public String readString(String name) {
-		int i = this.intValues.get(name, -1);
-		return i == -1 ? null : this.strings.get(i);
-	}
-
-	private <T extends ICRBinSerializable> T readObj(Class<T> elementType, CRBinDeserializer d) {
-		T t = this.newInstance(elementType);
+		}
+		var alt = altSchemas.get(altSchema);
+		CRBinDeserializer subDeserial = CRBinDeserializer.getNew();
+		subDeserial.classDeserializers = classDeserializers;
+		subDeserial.altSchemas = altSchemas;
+		subDeserial.strings = strings;
+		subDeserial.readDataFromSchema(alt, bytes);
+		return subDeserial;
+	}
+	private void readDataFromSchema(CRBinSchema schema, ByteBuffer bytes) 
+	{
+		// For each item in the schema,
+		// the schema type tells how to interpret the following byte
+		// into data which is mapped to the name.
+		for(var item : schema.getSchema()) 
+		{
+			int length;
+			String name = item.name();
+			switch(item.type()) 
+			{
+			case BOOLEAN:
+			case BYTE:
+				intValues.put(name, ByteArrayUtils.readByte(bytes));
+				break;
+			case DOUBLE:
+				doubleValues.put(name, ByteArrayUtils.readDouble(bytes));
+				break;
+			case FLOAT:
+				floatValues.put(name, ByteArrayUtils.readFloat(bytes));
+				break;
+			case INT:
+				intValues.put(name, ByteArrayUtils.readInt(bytes));
+				break;
+			case LONG:
+				longValues.put(name, ByteArrayUtils.readLong(bytes));
+				break;
+			case SHORT:
+				intValues.put(name, ByteArrayUtils.readShort(bytes));
+				break;
+			case STRING:
+				int stringId = ByteArrayUtils.readInt(bytes);
+				intValues.put(name, stringId);
+				break;
+			case OBJ:
+				var o = readObj(bytes);
+				objValues.put(name, o);
+				break;
+			case OBJ_ARRAY:
+				length = ByteArrayUtils.readInt(bytes);
+				CRBinDeserializer[] subDeserial = new CRBinDeserializer[length];
+				for(int i = 0; i < length; i++) 
+				{
+					subDeserial[i] = readObj(bytes);
+				}
+				objValues.put(name, subDeserial);
+				break;
+			case STRING_ARRAY:
+				readArray(bytes, name, len -> new String[len],
+						(arr, i) -> {arr[i] = strings.get(ByteArrayUtils.readInt(bytes));
+						});
+				break;
+			case BOOLEAN_ARRAY:
+				readArray(bytes, name, len -> new boolean[len],
+						(arr, i) -> {arr[i] = ByteArrayUtils.readByte(bytes) == 1;
+						});
+				break;
+			case BYTE_ARRAY:
+				readArray(bytes, name, len -> new byte[len],
+						(arr, i) -> {arr[i] = ByteArrayUtils.readByte(bytes);
+						});
+				break;
+			case DOUBLE_ARRAY:
+				readArray(bytes, name, len -> new double[len],
+						(arr, i) -> {arr[i] = ByteArrayUtils.readDouble(bytes);
+						});
+				break;
+			case FLOAT_ARRAY:
+				readArray(bytes, name, len -> new float[len],
+						(arr, i) -> {arr[i] = ByteArrayUtils.readFloat(bytes);
+						});
+				break;
+			case INT_ARRAY:
+				readArray(bytes, name, len -> new int[len],
+						(arr, i) -> {arr[i] = ByteArrayUtils.readInt(bytes);
+						});
+				break;
+			case LONG_ARRAY:
+				readArray(bytes, name, len -> new long[len],
+						(arr, i) -> {arr[i] = ByteArrayUtils.readLong(bytes);
+						});
+				break;
+			case SHORT_ARRAY:
+				readArray(bytes, name, len -> new short[len],
+						(arr, i) -> {arr[i] = ByteArrayUtils.readShort(bytes);
+						});
+				break;
+			default:
+				break;
+
+			}
+		}
+	}
+	private <T> void readArray(ByteBuffer bytes, String name,
+			IntFunction<T> arrCreator, 
+			ObjIntConsumer<T> perElement) 
+	{
+		int length = ByteArrayUtils.readInt(bytes);
+		if(length == -1) 
+		{
+			objValues.put(name, null);
+		}else 
+		{
+			T arr = arrCreator.apply(length);
+			for(int i = 0; i < length; i++) 
+			{
+				perElement.accept(arr, i);
+			}
+			
+			objValues.put(name, arr);
+		}
+	}
+
+	public String[] readStringArray(String name) 
+	{
+		return (String[]) objValues.get(name);
+	}
+
+	public boolean[] readBooleanArray(String name) 
+	{
+		return (boolean[]) objValues.get(name);
+	}
+
+	public byte[] readByteArray(String name) 
+	{
+		return (byte[]) objValues.get(name);
+	}
+
+	public short[] readShortArray(String name) 
+	{
+		return (short[]) objValues.get(name);
+	}
+
+	public int[] readIntArray(String name) 
+	{
+		return (int[]) objValues.get(name);
+	}
+
+	public long[] readLongArray(String name) 
+	{
+		return (long[]) objValues.get(name);
+	}
+
+	public float[] readFloatArray(String name) 
+	{
+		return (float[]) objValues.get(name);
+	}
+
+	public double[] readDoubleArray(String name) 
+	{
+		return (double[]) objValues.get(name);
+	}
+
+	public void prepareForRead(ByteBuffer bytes) 
+	{
+		schema = new CRBinSchema();
+		altSchemas = DynamicArrays.getNew(CRBinSchema.class);
+		// Read strings
+		int numStrings = ByteArrayUtils.readInt(bytes);
+		strings = DynamicArrays.getNew(String.class, numStrings);
+
+		for(int i = 0; i < numStrings; i++) 
+		{
+			strings.add(ByteArrayUtils.readString(bytes));
+		}
+
+		// Now read schemas
+		readSchema(schema, bytes);
+		// Now read alt schemas
+		int numAlt = ByteArrayUtils.readInt(bytes);
+		for(int i = 0; i < numAlt; i++) 
+		{
+			var alt = new CRBinSchema();
+			readSchema(alt, bytes);
+			altSchemas.add(alt);
+		}
+		// Now read actual data:
+		readDataFromSchema(schema, bytes);
+	}
+
+	public int readInt(String name, int defaultValue) 
+	{
+		return intValues.get(name, defaultValue);
+	}
+
+	public long readLong(String name, long defaultValue) 
+	{
+		return longValues.get(name, defaultValue);
+	}
+
+	public short readShort(String name, short defaultValue) 
+	{
+		return (short) intValues.get(name, defaultValue);
+	}
+
+	public float readFloat(String name, float defaultValue) 
+	{
+		return floatValues.get(name, defaultValue);
+	}
+
+	public boolean readBoolean(String name, boolean defaultValue) 
+	{
+		boolean b = intValues.get(name, defaultValue? 1 : 0) == 1;		
+		return b;
+	}
+	public String readString(String name)
+	{
+		int stringId = intValues.get(name, -1);
+		if(stringId==-1)return null;
+		String s = strings.get(stringId);
+		return s;
+	}
+	private <T extends ICRBinSerializable> T readObj(Class<T> elementType, CRBinDeserializer d)
+	{
+		T t = newInstance(elementType);
 		t.read(d);
 		return t;
 	}
 
-	public <T> T readObj(String name, Class<T> elementType) {
-		BiFunction<String, CRBinDeserializer, ?> bifunction = this.classDeserializers.get(elementType);
-		if (bifunction != null) {
-			return (T)bifunction.apply(name, this);
-		} else {
-			CRBinDeserializer crbindeserializer = (CRBinDeserializer)this.objValues.get(name);
-			if (crbindeserializer == null) {
-				return null;
-			} else if (ICRBinSerializable.class.isAssignableFrom(elementType)) {
-				return this.readObj(elementType, crbindeserializer);
-			} else {
-				throw new RuntimeException(
-					elementType.getSimpleName() + " neither has an associated class deserializer, nor is derived from ICosmicReachBinarySerializable!"
-				);
-			}
-		}
-	}
-
-	public CRBinDeserializer readRawObj(String name) {
-		return (CRBinDeserializer)this.objValues.get(name);
-	}
-
-	public CRBinDeserializer[] readRawObjArray(String name) {
-		return (CRBinDeserializer[])this.objValues.get(name);
-	}
-
-	public <T extends ICRBinSerializable> IDynamicArray<T> readObjArray(String name, Class<T> elementType) {
-		CRBinDeserializer[] acrbindeserializer = (CRBinDeserializer[])this.objValues.get(name);
-		IDynamicArray<T> idynamicarray = DynamicArrays.getNew(elementType, acrbindeserializer.length);
-
-		for (CRBinDeserializer crbindeserializer : acrbindeserializer) {
-			idynamicarray.add(crbindeserializer != null ? this.readObj(elementType, crbindeserializer) : null);
-		}
-
-		return idynamicarray;
-	}
-
-	private <T extends ICRBinSerializable> T newInstance(Class<T> type) {
-		try {
-			Constructor<T> constructor = type.getDeclaredConstructor();
-			constructor.setAccessible(true);
-			return constructor.newInstance();
-		} catch (SecurityException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException nosuchmethodexception) {
-			nosuchmethodexception.printStackTrace();
-			throw new RuntimeException(nosuchmethodexception);
-		}
-	}
-
-	public void autoRead(Object obj) {
-		for (Class<?> oclass = obj.getClass(); oclass != Object.class; oclass = oclass.getSuperclass()) {
-			Field[] afield = oclass.getDeclaredFields();
-
-			for (Field field : afield) {
-				if (field.isAnnotationPresent(CRBSerialized.class)) {
+	@SuppressWarnings("unchecked")
+	public <T> T readObj(String name, Class<T> elementType)
+	{
+		var func = classDeserializers.get(elementType);
+		if(func != null) 
+		{
+			return (T)func.apply(name, this);
+		}
+		var d = (CRBinDeserializer) objValues.get(name);
+		if(d == null) 
+		{
+			return null;
+		}
+		if(ICRBinSerializable.class.isAssignableFrom(elementType))
+		{
+			return (T) readObj((Class<ICRBinSerializable>)elementType, d);	
+		}
+		throw new RuntimeException(elementType.getSimpleName() 
+				+ " neither has an associated class deserializer, nor is derived from ICosmicReachBinarySerializable!");
+	}
+
+	public CRBinDeserializer readRawObj(String name) 
+	{
+		var backing = (CRBinDeserializer) objValues.get(name);
+		return backing;
+	}
+	public CRBinDeserializer[] readRawObjArray(String name) 
+	{
+		var backing = (CRBinDeserializer[]) objValues.get(name);
+		return backing;
+	}
+
+	public <T extends ICRBinSerializable> IDynamicArray<T> readObjArray(String name, Class<T> elementType) 
+	{
+		var backing = (CRBinDeserializer[]) objValues.get(name);
+		IDynamicArray<T> arr = DynamicArrays.getNew(elementType, backing.length);
+		for(var d : backing) 
+		{
+			arr.add(d != null ? readObj(elementType, d) : null);
+		}
+		return arr;
+	}
+
+	private <T extends ICRBinSerializable> T newInstance(Class<T> type) 
+	{
+		try 
+		{
+			var c = type.getDeclaredConstructor();
+			c.setAccessible(true);
+			return (T) c.newInstance();
+		} catch (NoSuchMethodException | SecurityException | InstantiationException 
+				| IllegalAccessException | IllegalArgumentException | InvocationTargetException e) 
+		{
+			e.printStackTrace();
+			throw new RuntimeException(e);
+		}
+	}
+
+	public void autoRead(Object obj) 
+	{
+		Class<?> clazz = obj.getClass();
+		
+		while(clazz != Object.class) 
+		{
+			var fields = clazz.getDeclaredFields();
+			
+			for(Field field : fields) 
+			{
+				if(field.isAnnotationPresent(CRBSerialized.class)) 
+				{
 					field.setAccessible(true);
-
-					try {
-						String s = field.getName();
-						Class<?> oclass1 = field.getType();
-						if (oclass1 == int.class) {
-							field.set(obj, this.readInt(s, field.getInt(obj)));
-						} else if (oclass1 == float.class) {
-							field.set(obj, this.readFloat(s, field.getFloat(obj)));
-						} else if (oclass1 == boolean.class) {
-							field.set(obj, this.readBoolean(s, field.getBoolean(obj)));
-						} else if (oclass1 == String.class) {
-							field.set(obj, this.readString(s));
-						} else {
-							if (oclass1.isPrimitive()) {
-								throw new RuntimeException("Not yet implemented for type: " + oclass1.getSimpleName());
-							}
-
-							field.set(obj, this.readObj(s, oclass1));
-						}
-					} catch (IllegalAccessException | IllegalArgumentException illegalargumentexception) {
-						illegalargumentexception.printStackTrace();
+					try 
+					{
+						String name = field.getName();
+						var type = field.getType();
+						if(type == int.class) 
+						{
+							field.set(obj, readInt(name, field.getInt(obj)));
+						}
+						else if(type == float.class) 
+						{
+							field.set(obj, readFloat(name, field.getFloat(obj)));
+						}else if(type == boolean.class) 
+						{
+							field.set(obj, readBoolean(name, field.getBoolean(obj)));
+						}else if(type == String.class)
+						{
+							field.set(obj, readString(name));
+						}else if(!type.isPrimitive()) 
+						{
+							field.set(obj, readObj(name, type));
+						}
+						else
+						{
+							throw new RuntimeException("Not yet implemented for type: " + type.getSimpleName());
+						}
+					} catch (IllegalArgumentException | IllegalAccessException e) 
+					{
+						e.printStackTrace();
 					}
 				}
 			}
+			clazz = clazz.getSuperclass();
 		}
 	}
 }
