--- a/finalforeach/cosmicreach/savelib/crbin/CRBinSerializer.java
+++ b/finalforeach/cosmicreach/savelib/crbin/CRBinSerializer.java
@@ -1,389 +_,496 @@
 package finalforeach.cosmicreach.savelib.crbin;
 
-import finalforeach.cosmicreach.savelib.IByteArray;
-import finalforeach.cosmicreach.savelib.utils.ByteArrayUtils;
-import finalforeach.cosmicreach.savelib.utils.DynamicArrays;
-import finalforeach.cosmicreach.savelib.utils.IDynamicArray;
-import finalforeach.cosmicreach.savelib.utils.TriConsumer;
 import java.lang.reflect.Field;
 import java.util.Base64;
 import java.util.HashMap;
 import java.util.Objects;
 import java.util.function.IntConsumer;
 
-public class CRBinSerializer {
+import finalforeach.cosmicreach.savelib.IByteArray;
+import finalforeach.cosmicreach.savelib.utils.ByteArrayUtils;
+import finalforeach.cosmicreach.savelib.utils.DynamicArrays;
+import finalforeach.cosmicreach.savelib.utils.IDynamicArray;
+import finalforeach.cosmicreach.savelib.utils.TriConsumer;
+
+public class CRBinSerializer
+{	
 	private static final HashMap<Class<?>, TriConsumer<CRBinSerializer, String, ?>> defaultClassSerializers = new HashMap<>();
 	private HashMap<Class<?>, TriConsumer<CRBinSerializer, String, ?>> classSerializers = defaultClassSerializers;
+
 	CRBinSchema schema = new CRBinSchema();
 	IDynamicArray<CRBinSchema> altSchemas = DynamicArrays.getNew(CRBinSchema.class);
 	IDynamicArray<String> strings = DynamicArrays.getNew(String.class);
 	IByteArray bytes = DynamicArrays.getNewByteArray();
 
-	public static CRBinSerializer getNew() {
+	public static CRBinSerializer getNew() 
+	{
 		return new CRBinSerializer();
 	}
-
-	public static boolean isThereDefaultClassSerializer(Class<?> clazz) {
+	
+	public static boolean isThereDefaultClassSerializer(Class<?> clazz) 
+	{
 		return defaultClassSerializers.containsKey(clazz);
 	}
 
-	public static <T> void registerDefaultClassSerializer(Class<T> clazz, TriConsumer<CRBinSerializer, String, T> consumer) {
-		synchronized (defaultClassSerializers) {
-			if (isThereDefaultClassSerializer(clazz)) {
+	public static <T> void registerDefaultClassSerializer(Class<T> clazz, TriConsumer<CRBinSerializer, String, T> consumer) 
+	{
+		synchronized (defaultClassSerializers) 
+		{
+			if(isThereDefaultClassSerializer(clazz)) 
+			{
 				throw new RuntimeException("Cannot register a default class serializer twice!");
-			} else {
-				defaultClassSerializers.put(clazz, consumer);
 			}
-		}
-	}
-
-	public <T> void registerClassSerializer(Class<T> clazz, TriConsumer<CRBinSerializer, String, T> consumer) {
-		if (this.classSerializers == defaultClassSerializers) {
-			this.classSerializers = new HashMap<>(defaultClassSerializers);
-		}
-
-		this.classSerializers.put(clazz, consumer);
-	}
-
-	public byte[] toBytes() {
-		return this.toByteArray().toArray();
-	}
-
-	public IByteArray toByteArray() {
-		IByteArray ibytearray = DynamicArrays.getNewByteArray();
-		ByteArrayUtils.writeInt(ibytearray, this.strings.size());
-
-		for (String s : this.strings) {
-			ByteArrayUtils.writeString(ibytearray, s);
-		}
-
-		ibytearray.addAll(this.schema.getBytes());
-		ByteArrayUtils.writeInt(ibytearray, this.altSchemas.size());
-
-		for (CRBinSchema crbinschema : this.altSchemas) {
-			ibytearray.addAll(crbinschema.getBytes());
-		}
-
-		ibytearray.addAll(this.bytes);
-		return ibytearray;
-	}
-
-	public String toBase64() {
-		return Base64.getEncoder().encodeToString(this.toBytes());
-	}
-
-	private void writeNullArray(String name, SchemaType type) {
-		this.schema.add(name, type);
-		ByteArrayUtils.writeInt(this.bytes, -1);
-	}
-
-	public void writeArray(String name, SchemaType type, int arrayLength, IntConsumer forEach) {
-		this.schema.add(name, type);
-		ByteArrayUtils.writeInt(this.bytes, arrayLength);
-
-		for (int i = 0; i < arrayLength; i++) {
-			forEach.accept(i);
-		}
-	}
-
-	public void writeArray(String name, SchemaType type, int offset, int arrayLength, IntConsumer forEach) {
-		this.schema.add(name, type);
-		ByteArrayUtils.writeInt(this.bytes, arrayLength);
-
-		for (int i = offset; i < arrayLength; i++) {
-			forEach.accept(i);
-		}
-	}
-
-	public void writeByteArray(String name, byte[] array) {
-		this.writeArray(name, SchemaType.BYTE_ARRAY, array.length, i -> this.writeByte(null, array[i]));
-	}
-
-	public void writeBooleanArray(String name, boolean[] array) {
-		this.writeArray(name, SchemaType.BOOLEAN_ARRAY, array.length, i -> this.writeBoolean(null, array[i]));
-	}
-
-	public void writeShortArray(String name, short[] array) {
-		this.writeArray(name, SchemaType.SHORT_ARRAY, array.length, i -> this.writeShort(null, array[i]));
-	}
-
-	public void writeIntArray(String name, int[] array) {
-		this.writeArray(name, SchemaType.INT_ARRAY, array.length, i -> this.writeInt(null, array[i]));
-	}
-
-	public void writeLongArray(String name, long[] array) {
-		this.writeArray(name, SchemaType.LONG_ARRAY, array.length, i -> this.writeLong(null, array[i]));
-	}
-
-	public void writeFloatArray(String name, float[] array) {
-		this.writeArray(name, SchemaType.FLOAT_ARRAY, array.length, i -> this.writeFloat(null, array[i]));
-	}
-
-	public void writeDoubleArray(String name, double[] array) {
-		this.writeArray(name, SchemaType.DOUBLE_ARRAY, array.length, i -> this.writeDouble(null, array[i]));
-	}
-
-	public void writeStringArray(String name, String[] array) {
-		this.writeArray(name, SchemaType.STRING_ARRAY, array.length, i -> this.writeString(null, array[i]));
-	}
-
-	public void writeStringArray(String name, String[] array, int length) {
-		this.writeArray(name, SchemaType.STRING_ARRAY, length, i -> this.writeString(null, array[i]));
-	}
-
-	public void writeNullByteArray(String name) {
-		this.writeNullArray(name, SchemaType.BYTE_ARRAY);
-	}
-
-	public void writeNullBooleanArray(String name) {
-		this.writeNullArray(name, SchemaType.BOOLEAN_ARRAY);
-	}
-
-	public void writeNullShortArray(String name) {
-		this.writeNullArray(name, SchemaType.SHORT_ARRAY);
-	}
-
-	public void writeNullIntArray(String name) {
-		this.writeNullArray(name, SchemaType.INT_ARRAY);
-	}
-
-	public void writeNullLongArray(String name) {
-		this.writeNullArray(name, SchemaType.LONG_ARRAY);
-	}
-
-	public void writeNullFloatArray(String name) {
-		this.writeNullArray(name, SchemaType.FLOAT_ARRAY);
-	}
-
-	public void writeNullDoubleArray(String name) {
-		this.writeNullArray(name, SchemaType.DOUBLE_ARRAY);
-	}
-
-	public void writeNullStringArray(String name) {
-		this.writeNullArray(name, SchemaType.STRING_ARRAY);
-	}
-
-	public void writeNullObjectArray(String name) {
-		this.writeNullArray(name, SchemaType.OBJ_ARRAY);
-	}
-
-	public <T extends ICRBinSerializable> void writeObjArray(String name, T[] array) {
-		this.writeArray(name, SchemaType.OBJ_ARRAY, array.length, i -> this.writeObj(null, array[i]));
-	}
-
-	public <T extends ICRBinSerializable> void writeObjArray(String name, T[] array, int offset, int length) {
-		this.writeArray(name, SchemaType.OBJ_ARRAY, offset, length, i -> this.writeObj(null, array[i]));
-	}
-
-	public void writeBoolean(String name, boolean bool) {
-		this.schema.add(name, SchemaType.BOOLEAN);
-		ByteArrayUtils.writeByte(this.bytes, bool ? 1 : 0);
-	}
-
-	public void writeByte(String name, byte i) {
-		this.schema.add(name, SchemaType.BYTE);
-		ByteArrayUtils.writeByte(this.bytes, i);
-	}
-
-	public void writeInt(String name, int i) {
-		this.schema.add(name, SchemaType.INT);
-		ByteArrayUtils.writeInt(this.bytes, i);
-	}
-
-	public void writeShort(String name, short s) {
-		this.schema.add(name, SchemaType.SHORT);
-		ByteArrayUtils.writeShort(this.bytes, s);
-	}
-
-	public void writeLong(String name, long l) {
-		this.schema.add(name, SchemaType.LONG);
-		ByteArrayUtils.writeLong(this.bytes, l);
-	}
-
-	public void writeFloat(String name, float f) {
-		this.schema.add(name, SchemaType.FLOAT);
-		ByteArrayUtils.writeFloat(this.bytes, f);
-	}
-
-	public void writeDouble(String name, double d) {
-		this.schema.add(name, SchemaType.DOUBLE);
-		ByteArrayUtils.writeDouble(this.bytes, d);
-	}
-
-	public void writeString(String name, String value) {
-		this.schema.add(name, SchemaType.STRING);
-		int i = this.strings.indexOf(value, false);
-		if (i == -1) {
-			i = this.strings.size();
-			this.strings.add(value);
-		}
-
-		ByteArrayUtils.writeInt(this.bytes, i);
-	}
-
-	public <T> void writeObj(Class<T> elementType, String name, Object item) {
-		TriConsumer<CRBinSerializer, String, T> triconsumer = (TriConsumer<CRBinSerializer, String, T>)this.classSerializers.get(elementType);
-		if (triconsumer != null) {
-			triconsumer.accept(this, name, (T)item);
-		} else if (ICRBinSerializable.class.isAssignableFrom(elementType)) {
-			this.writeObj(name, (T)((ICRBinSerializable)item));
-		} else {
-			throw new RuntimeException(elementType.getSimpleName() + " neither has an associated class serializer, nor is derived from ICosmicReachBinarySerializable!");
-		}
-	}
-
-	public <T extends ICRBinSerializable> void writeObj(String name, T item) {
-		CRBinSchema crbinschema = this.schema;
-		IByteArray ibytearray = this.bytes;
-		this.bytes = DynamicArrays.getNewByteArray();
-		if (name != null) {
-			crbinschema.add(name, SchemaType.OBJ);
-		}
-
-		if (item != null) {
-			this.schema = new CRBinSchema();
+			defaultClassSerializers.put(clazz, consumer);
+		}
+	}
+
+	public <T> void registerClassSerializer(Class<T> clazz, TriConsumer<CRBinSerializer, String, T> consumer) 
+	{
+		if(classSerializers == defaultClassSerializers) 
+		{
+			classSerializers = new HashMap<>(defaultClassSerializers);
+		}
+		classSerializers.put(clazz, consumer);
+	}
+	
+	public byte[] toBytes() 
+	{
+		return toByteArray().toArray();
+	}
+
+	public IByteArray toByteArray() 
+	{		
+		IByteArray bytesToWrite = DynamicArrays.getNewByteArray();
+		// First write all common strings
+
+		ByteArrayUtils.writeInt(bytesToWrite, strings.size());
+		for(String s : strings) 
+		{
+			ByteArrayUtils.writeString(bytesToWrite, s);
+		}
+
+		// Then write the bytes of the current schema
+
+		bytesToWrite.addAll(schema.getBytes());
+
+		// Then write the bytes of the other schemas
+
+		ByteArrayUtils.writeInt(bytesToWrite, altSchemas.size());
+		for(var s : altSchemas) 
+		{
+			bytesToWrite.addAll(s.getBytes());	
+		}
+
+		// Then write the binary data
+		bytesToWrite.addAll(bytes);
+
+		return bytesToWrite;
+	}
+
+	public String toBase64() 
+	{
+		return Base64.getEncoder().encodeToString(toBytes());
+	}
+
+
+	private void writeNullArray(String name, SchemaType type) 
+	{
+		schema.add(name, type);
+		ByteArrayUtils.writeInt(bytes, -1);
+	}
+
+	public void writeArray(String name, SchemaType type, int arrayLength, IntConsumer forEach) 
+	{
+		schema.add(name, type);
+		ByteArrayUtils.writeInt(bytes, arrayLength);
+		for(int i = 0; i < arrayLength; i++) 
+		{
+			forEach.accept(i);
+		}
+	}
+	
+	public void writeArray(String name, SchemaType type, int offset, int arrayLength, IntConsumer forEach) 
+	{
+		schema.add(name, type);
+		ByteArrayUtils.writeInt(bytes, arrayLength);
+		for(int i = offset; i < arrayLength; i++) 
+		{
+			forEach.accept(i);
+		}
+	}
+
+	public void writeByteArray(String name, byte[] array) 
+	{
+		writeArray(name, SchemaType.BYTE_ARRAY, array.length, (i) -> writeByte(null, array[i]));
+	}
+
+	public void writeBooleanArray(String name, boolean[] array) 
+	{
+		writeArray(name, SchemaType.BOOLEAN_ARRAY, array.length, (i) -> writeBoolean(null, array[i]));
+	}
+
+	public void writeShortArray(String name, short[] array) 
+	{
+		writeArray(name, SchemaType.SHORT_ARRAY, array.length, (i) -> writeShort(null, array[i]));
+	}
+
+	public void writeIntArray(String name, int[] array) 
+	{
+		writeArray(name, SchemaType.INT_ARRAY, array.length, (i) -> writeInt(null, array[i]));
+	}
+
+	public void writeLongArray(String name, long[] array) 
+	{
+		writeArray(name, SchemaType.LONG_ARRAY, array.length, (i) -> writeLong(null, array[i]));
+	}
+
+	public void writeFloatArray(String name, float[] array) 
+	{
+		writeArray(name, SchemaType.FLOAT_ARRAY, array.length, (i) -> writeFloat(null, array[i]));
+	}
+
+	public void writeDoubleArray(String name, double[] array) 
+	{
+		writeArray(name, SchemaType.DOUBLE_ARRAY, array.length, (i) -> writeDouble(null, array[i]));
+	}
+
+	public void writeStringArray(String name, String[] array) 
+	{
+		writeArray(name, SchemaType.STRING_ARRAY, array.length, (i) -> writeString(null, array[i]));
+	}
+	public void writeStringArray(String name, String[] array, int length) 
+	{
+		writeArray(name, SchemaType.STRING_ARRAY, length, (i) -> writeString(null, array[i]));
+	}
+	
+
+	public void writeNullByteArray(String name) 
+	{
+		writeNullArray(name, SchemaType.BYTE_ARRAY);
+	}
+
+	public void writeNullBooleanArray(String name) 
+	{
+		writeNullArray(name, SchemaType.BOOLEAN_ARRAY);
+	}
+
+	public void writeNullShortArray(String name) 
+	{
+		writeNullArray(name, SchemaType.SHORT_ARRAY);
+	}
+
+	public void writeNullIntArray(String name) 
+	{
+		writeNullArray(name, SchemaType.INT_ARRAY);
+	}
+
+	public void writeNullLongArray(String name) 
+	{
+		writeNullArray(name, SchemaType.LONG_ARRAY);
+	}
+
+	public void writeNullFloatArray(String name) 
+	{
+		writeNullArray(name, SchemaType.FLOAT_ARRAY);
+	}
+
+	public void writeNullDoubleArray(String name) 
+	{
+		writeNullArray(name, SchemaType.DOUBLE_ARRAY);
+	}
+
+	public void writeNullStringArray(String name) 
+	{
+		writeNullArray(name, SchemaType.STRING_ARRAY);
+	}
+
+	public void writeNullObjectArray(String name) 
+	{
+		writeNullArray(name, SchemaType.OBJ_ARRAY);
+	}
+
+	public <T extends ICRBinSerializable> void writeObjArray(String name, T[] array)
+	{
+		writeArray(name, SchemaType.OBJ_ARRAY, array.length, (i) -> writeObj(null, array[i]));
+	}
+	
+	public <T extends ICRBinSerializable> void writeObjArray(String name, T[] array, int offset, int length)
+	{
+		writeArray(name, SchemaType.OBJ_ARRAY, offset, length, (i) -> writeObj(null, array[i]));
+	}
+
+	public void writeBoolean(String name, boolean bool) 
+	{
+		schema.add(name, SchemaType.BOOLEAN);
+		ByteArrayUtils.writeByte(bytes, bool ? 1 : 0);
+	}
+
+	public void writeByte(String name, byte i) 
+	{
+		schema.add(name, SchemaType.BYTE);
+		ByteArrayUtils.writeByte(bytes, i);
+	}
+
+	public void writeInt(String name, int i) 
+	{
+		schema.add(name, SchemaType.INT);
+		ByteArrayUtils.writeInt(bytes, i);
+	}
+
+	public void writeShort(String name, short s) 
+	{
+		schema.add(name, SchemaType.SHORT);
+		ByteArrayUtils.writeShort(bytes, s);
+	}
+
+	public void writeLong(String name, long l) 
+	{
+		schema.add(name, SchemaType.LONG);
+		ByteArrayUtils.writeLong(bytes, l);
+	}
+
+	public void writeFloat(String name, float f) 
+	{
+		schema.add(name, SchemaType.FLOAT);
+		ByteArrayUtils.writeFloat(bytes, f);
+	}
+	public void writeDouble(String name, double d) 
+	{
+		schema.add(name, SchemaType.DOUBLE);
+		ByteArrayUtils.writeDouble(bytes, d);
+	}
+
+	public void writeString(String name, String value) 
+	{
+		schema.add(name, SchemaType.STRING);
+
+		// Reference the string by ID rather than serializing it directly 
+		int stringId = strings.indexOf(value, false);
+		if(stringId == -1) 
+		{
+			// It's not stored yet, so add it to the list of strings,
+			// so that there is a valid ID to reference
+			stringId = strings.size();
+			strings.add(value);
+		}
+
+		// Write the string's ID
+		ByteArrayUtils.writeInt(bytes, stringId);
+
+	}
+
+	@SuppressWarnings("unchecked")
+	public <T> void writeObj(Class<T> elementType, String name, Object item) 
+	{
+		var consumer = (TriConsumer<CRBinSerializer, String, T>)classSerializers.get(elementType);
+		if(consumer != null) 
+		{
+			consumer.accept(this, name, (T) item);
+			return;
+		}
+		if(ICRBinSerializable.class.isAssignableFrom(elementType))
+		{
+			writeObj(name, (ICRBinSerializable) item);
+			return;
+		}
+		throw new RuntimeException(elementType.getSimpleName() 
+				+ " neither has an associated class serializer, nor is derived from ICosmicReachBinarySerializable!");
+	}
+	
+	public <T extends ICRBinSerializable> void writeObj(String name, T item) 
+	{
+		var oldSchema = schema;
+		var oldBytes = bytes;
+
+		bytes = DynamicArrays.getNewByteArray();
+
+		if(name != null) 
+		{
+			oldSchema.add(name, SchemaType.OBJ);
+		}
+
+		if(item != null) 
+		{
+			schema = new CRBinSchema();
 			item.write(this);
-			if (!this.altSchemas.contains(this.schema, false)) {
-				this.altSchemas.add(this.schema);
+			if(!altSchemas.contains(schema, false)) 
+			{
+				altSchemas.add(schema);
 			}
 
-			for (int i = 0; i < this.altSchemas.size(); i++) {
-				CRBinSchema crbinschema1 = this.altSchemas.get(i);
-				if (crbinschema1.equals(this.schema)) {
-					ByteArrayUtils.writeInt(ibytearray, i);
+			for(int i = 0; i < altSchemas.size(); i++) 
+			{
+				var s = altSchemas.get(i);
+				if(s.equals(schema)) 
+				{
+					ByteArrayUtils.writeInt(oldBytes, i);
 					break;
 				}
 			}
-		} else {
-			ByteArrayUtils.writeInt(ibytearray, -1);
+		}else 
+		{
+			ByteArrayUtils.writeInt(oldBytes, -1);
 		}
 
-		ibytearray.addAll(this.bytes);
-		this.schema = crbinschema;
-		this.bytes = ibytearray;
+		oldBytes.addAll(bytes);
+
+		schema = oldSchema;
+		bytes = oldBytes;
 	}
 
-	public void autoWriteDifference(Object prototype, Object obj) {
-		Class<?> oclass = prototype.getClass();
-		Class<?> oclass1 = obj.getClass();
-		if (!oclass.isInstance(obj)) {
+	public void autoWriteDifference(Object prototype, Object obj) 
+	{
+		Class<?> prototypeClazz = prototype.getClass();
+		Class<?> clazz = obj.getClass();
+		
+		if(!prototypeClazz.isInstance(obj)) 
+		{
 			throw new RuntimeException("Object is not an instance of the class or instance of a subclass of the prototype's class.");
-		} else {
-			while (oclass1 != Object.class) {
-				Field[] afield = oclass1.getDeclaredFields();
-
-				for (Field field : afield) {
-					if (field.isAnnotationPresent(CRBSerialized.class)) {
-						field.setAccessible(true);
-
-						try {
-							String s = field.getName();
-							Class<?> oclass2 = field.getType();
-
-							Field field1;
-							try {
-								if (oclass == oclass1) {
-									;
-								}
-
-								field1 = oclass.getDeclaredField(s);
-							} catch (SecurityException | NoSuchFieldException nosuchfieldexception) {
-								field1 = null;
-							}
-
-							if (oclass2 == int.class) {
-								int i = field.getInt(obj);
-								if (field1 != null) {
-									int j = field1.getInt(prototype);
-									if (j == i) {
-										continue;
-									}
-								}
-
-								this.writeInt(s, i);
-							} else if (oclass2 == float.class) {
-								float f = field.getFloat(obj);
-								if (field1 != null) {
-									float f1 = field1.getFloat(prototype);
-									if (f1 == f) {
-										continue;
-									}
-								}
-
-								this.writeFloat(s, f);
-							} else if (oclass2 == boolean.class) {
-								boolean flag = field.getBoolean(obj);
-								if (field1 != null) {
-									boolean flag1 = field1.getBoolean(prototype);
-									if (flag1 == flag) {
-										continue;
-									}
-								}
-
-								this.writeBoolean(s, flag);
-							} else {
-								if (oclass2.isPrimitive()) {
-									throw new RuntimeException("Not yet implemented for type: " + oclass2.getSimpleName());
-								}
-
-								Object object = field.get(obj);
-								if (field1 != null) {
-									Object object1 = field1.get(prototype);
-									if (Objects.equals(object, object1)) {
-										continue;
-									}
-								}
-
-								if (oclass2 == String.class) {
-									this.writeString(s, (String)object);
-								} else {
-									this.writeObj(oclass2, s, object);
-								}
-							}
-						} catch (IllegalAccessException | IllegalArgumentException illegalargumentexception) {
-							System.err.println("Write error for " + obj.getClass().getSimpleName());
-							illegalargumentexception.printStackTrace();
-						}
+		}
+		
+		while(clazz != Object.class) 
+		{
+			var fields = clazz.getDeclaredFields();
+			
+			for(Field field : fields) 
+			{
+				if(field.isAnnotationPresent(CRBSerialized.class)) 
+				{
+					field.setAccessible(true);
+					try 
+					{
+						String name = field.getName();
+						var type = field.getType();
+						Field protoField;
+						try
+						{
+							if(prototypeClazz == clazz) 
+							{
+								protoField = field; 
+							}
+							protoField = prototypeClazz.getDeclaredField(name);
+							protoField.setAccessible(true);
+						} catch (NoSuchFieldException | SecurityException e)
+						{
+							protoField = null;
+						}
+						if(type == int.class) 
+						{
+							var objVal = field.getInt(obj);
+							if(protoField != null) 
+							{
+								var protoVal = protoField.getInt(prototype);
+								if(protoVal == objVal) 
+								{
+									continue;
+								}
+							}
+							writeInt(name, objVal);
+						}
+						else if(type == float.class) 
+						{
+							var objVal = field.getFloat(obj);
+							if(protoField != null) 
+							{
+								var protoVal = protoField.getFloat(prototype);
+								if(protoVal == objVal) 
+								{
+									continue;
+								}
+							}
+							writeFloat(name, objVal);
+						}else if(type == boolean.class) 
+						{
+							var objVal = field.getBoolean(obj);
+							if(protoField != null) 
+							{
+								var protoVal = protoField.getBoolean(prototype);
+								if(protoVal == objVal) 
+								{
+									continue;
+								}
+							}
+							writeBoolean(name, objVal);
+						}
+						else if(!type.isPrimitive())
+						{
+							var objVal = field.get(obj);
+							if(protoField != null) 
+							{
+								var protoVal = protoField.get(prototype);
+								if(Objects.equals(objVal, protoVal)) 
+								{
+									continue;
+								}
+							}
+							if(type == String.class) 
+							{
+								writeString(name, (String)objVal);
+							}else 
+							{
+								writeObj(type, name, objVal);	
+							}
+						}else 
+						{
+							throw new RuntimeException("Not yet implemented for type: " + type.getSimpleName());
+						}
+					} catch (IllegalArgumentException | IllegalAccessException e) 
+					{
+						System.err.println("Write error for " + obj.getClass().getSimpleName());
+						e.printStackTrace();
 					}
 				}
-
-				oclass1 = oclass1.getSuperclass();
 			}
+			clazz = clazz.getSuperclass();
 		}
 	}
-
-	public void autoWrite(Object obj) {
-		for (Class<?> oclass = obj.getClass(); oclass != Object.class; oclass = oclass.getSuperclass()) {
-			Field[] afield = oclass.getDeclaredFields();
-
-			for (Field field : afield) {
-				if (field.isAnnotationPresent(CRBSerialized.class)) {
+	
+	public void autoWrite(Object obj)
+	{
+		Class<?> clazz = obj.getClass();
+		while(clazz != Object.class) 
+		{
+			var fields = clazz.getDeclaredFields();
+			
+			for(Field field : fields) 
+			{
+				if(field.isAnnotationPresent(CRBSerialized.class)) 
+				{
 					field.setAccessible(true);
-
-					try {
-						String s = field.getName();
-						Class<?> oclass1 = field.getType();
-						if (oclass1 == int.class) {
-							this.writeInt(s, field.getInt(obj));
-						} else if (oclass1 == float.class) {
-							this.writeFloat(s, field.getFloat(obj));
-						} else if (oclass1 == boolean.class) {
-							this.writeBoolean(s, field.getBoolean(obj));
-						} else if (oclass1 == String.class) {
-							this.writeString(s, (String)field.get(obj));
-						} else {
-							if (oclass1.isPrimitive()) {
-								throw new RuntimeException("Not yet implemented for type: " + oclass1.getSimpleName());
-							}
-
-							this.writeObj(oclass1, s, field.get(obj));
-						}
-					} catch (IllegalAccessException | IllegalArgumentException illegalargumentexception) {
+					try 
+					{
+						String name = field.getName();
+						var type = field.getType();
+						if(type == int.class) 
+						{
+							writeInt(name, field.getInt(obj));
+						}
+						else if(type == float.class) 
+						{
+							writeFloat(name, field.getFloat(obj));
+						}else if(type == boolean.class) 
+						{
+							writeBoolean(name, field.getBoolean(obj));
+						}else if(type == String.class) 
+						{
+							writeString(name, (String) field.get(obj));
+						}
+						else if(!type.isPrimitive())
+						{
+							writeObj(type, name, field.get(obj));
+						}else 
+						{
+							throw new RuntimeException("Not yet implemented for type: " + type.getSimpleName());
+						}
+					} catch (IllegalArgumentException | IllegalAccessException e) 
+					{
 						System.err.println("Write error for " + obj.getClass().getSimpleName());
-						illegalargumentexception.printStackTrace();
+						e.printStackTrace();
 					}
 				}
 			}
+			clazz = clazz.getSuperclass();
 		}
+		
 	}
 }
