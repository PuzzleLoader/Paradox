--- a/finalforeach/cosmicreach/savelib/blockdata/LayeredBlockData.java
+++ b/finalforeach/cosmicreach/savelib/blockdata/LayeredBlockData.java
@@ -1,7 +_,14 @@
 package finalforeach.cosmicreach.savelib.blockdata;
 
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
 import finalforeach.cosmicreach.savelib.IChunkByteReader;
 import finalforeach.cosmicreach.savelib.IChunkByteWriter;
+import finalforeach.cosmicreach.savelib.ISavedChunk;
+import finalforeach.cosmicreach.savelib.SaveFileConstants;
 import finalforeach.cosmicreach.savelib.blockdata.layers.BlockBitLayer;
 import finalforeach.cosmicreach.savelib.blockdata.layers.BlockByteLayer;
 import finalforeach.cosmicreach.savelib.blockdata.layers.BlockHalfNibbleLayer;
@@ -10,278 +_,328 @@
 import finalforeach.cosmicreach.savelib.blockdata.layers.IBlockLayer;
 import finalforeach.cosmicreach.savelib.blockdata.layers.IBlockSingleLayer;
 import finalforeach.cosmicreach.savelib.blockdata.layers.SharedBlockSingleLayer;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.function.Function;
-import java.util.function.Predicate;
-
-public class LayeredBlockData<T> implements IBlockData<T> {
-	private IBlockLayer<T>[] layers = new IBlockLayer[16];
+
+public class LayeredBlockData<T> implements IBlockData<T>
+{
+	@SuppressWarnings("unchecked")
+	private IBlockLayer<T>[] layers = new IBlockLayer[CHUNK_WIDTH];
+
 	private T[] blockStatePalette;
 	private int paletteSize = 0;
+
 	private boolean allowCleaning = true;
 
-	public LayeredBlockData(int defaultPaletteSize) {
-		this.blockStatePalette = (T[])(new Object[defaultPaletteSize]);
-	}
-
-	public LayeredBlockData() {
-		this(8);
-	}
-
-	public LayeredBlockData(T defaultBlockState) {
-		this(8);
-		this.addToPalette(defaultBlockState);
-
-		for (int i = 0; i < 16; i++) {
-			this.fillLayer(defaultBlockState, i);
+	@SuppressWarnings("unchecked")
+	public LayeredBlockData(int defaultPaletteSize)
+	{
+		blockStatePalette = (T[])new Object[defaultPaletteSize];
+	}
+	public LayeredBlockData() 
+	{
+		this(8);
+	}
+	public LayeredBlockData(T defaultBlockState)
+	{
+		this(8);
+		addToPalette(defaultBlockState);
+		for(int j = 0; j < CHUNK_WIDTH; j++) 
+		{
+			fillLayer(defaultBlockState, j);
 		}
 	}
 
-	public IBlockLayer<T>[] getLayers() {
-		return this.layers;
-	}
-
-	@Override
-	public T getBlockValue(int localX, int localY, int localZ) {
-		return this.layers[localY].getBlockValue(this, localX, localZ);
-	}
-
-	@Override
-	public IBlockData<T> setBlockValue(T blockState, int localX, int localY, int localZ) {
-		this.layers[localY].setBlockValue(this, blockState, localX, localY, localZ);
+	public IBlockLayer<T>[] getLayers()
+	{
+		return layers;
+	}
+	@Override
+	public T getBlockValue(int localX, int localY, int localZ) 
+	{
+		return layers[localY].getBlockValue(this, localX, localZ);
+	}
+
+	@Override
+	public IBlockData<T> setBlockValue(T blockState, int localX, int localY, int localZ) 
+	{
+		layers[localY].setBlockValue(this, blockState, localX, localY, localZ);
 		return this;
 	}
-
 	@Override
-	public IBlockData<T> fill(T blockState) {
-		return new SingleBlockData<>(blockState);
+	public IBlockData<T> fill(T blockState) 
+	{
+		return new SingleBlockData<T>(blockState);
 	}
 
 	@Override
-	public IBlockData<T> fillLayer(T blockState, int localY) {
-		if (this.layers[localY] == null || this.layers[localY] instanceof IBlockSingleLayer) {
-			this.setLayer(localY, SharedBlockSingleLayer.get(this, blockState));
+	public IBlockData<T> fillLayer(T blockState, int localY)
+	{
+		if(layers[localY] == null || layers[localY] instanceof IBlockSingleLayer) 
+		{
+			setLayer(localY, SharedBlockSingleLayer.get(this, blockState));
 		}
 
-		for (int i = 0; i < 16; i++) {
-			if (!(this.layers[i] instanceof IBlockSingleLayer<T> iblocksinglelayer) || iblocksinglelayer.getBlockValue() != blockState) {
+		for(int i = 0; i < CHUNK_WIDTH; i++) 
+		{
+			if(!(layers[i] instanceof IBlockSingleLayer<T> s && s.getBlockValue() == blockState)) 
+			{
 				return this;
 			}
 		}
-
-		return this.fill(blockState);
+		return fill(blockState);
 	}
 
 	@Override
-	public boolean isEntirely(Predicate<T> predicate) {
-		T[] at = this.blockStatePalette;
-		int i = this.getPaletteSize();
-
-		for (int j = 0; j < i; j++) {
-			T t = at[j];
-			if (!predicate.test(t)) {
-				return false;
-			}
+	public boolean isEntirely(Predicate<T> predicate) 
+	{
+		var palette = blockStatePalette;
+		final int paletteSize = getPaletteSize();
+		for(int i = 0; i < paletteSize; i++) 
+		{
+			T b = palette[i];
+			if(!predicate.test(b))return false;
 		}
 
 		return true;
 	}
-
+	
 	@Override
-	public boolean hasValueInPalette(T value) {
-		T[] at = this.blockStatePalette;
-		int i = this.getPaletteSize();
-
-		for (int j = 0; j < i; j++) {
-			T t = at[j];
-			if (t == value) {
-				return true;
-			}
+	public boolean hasValueInPalette(T value) 
+	{
+		var palette = blockStatePalette;
+		final int paletteSize = getPaletteSize();
+		for(int i = 0; i < paletteSize; i++) 
+		{
+			T b = palette[i];
+			if(b == value)return true;
 		}
-
 		return false;
 	}
 
 	@Override
-	public boolean isEntirely(T blockValue) {
-		return this.getPaletteSize() == 1 && this.getBlockValueFromPaletteId(0) == blockValue;
-	}
-
-	@Override
-	public int getUniqueBlockValuesCount() {
-		return this.getPaletteSize();
-	}
-
-	public int getPaletteSize() {
-		return this.paletteSize;
-	}
-
-	public void setLayer(int yLevel, IBlockLayer<T> layer) {
-		if (layer instanceof IBlockSingleLayer<T> iblocksinglelayer) {
-			T t = iblocksinglelayer.getBlockValue();
-			if (!this.paletteHasValue(t)) {
-				this.addToPalette(t);
-			}
-		}
-
-		this.layers[yLevel] = layer;
-	}
-
-	public IBlockLayer<T> getLayer(int yLevel) {
-		return this.layers[yLevel];
-	}
-
-	@Override
-	public int getBlockValueID(T blockValue) {
-		int i = this.getPaletteSize();
-
-		for (int j = 0; j < i; j++) {
-			if (this.blockStatePalette[j] == blockValue) {
-				return j;
-			}
-		}
-
+	public boolean isEntirely(T blockValue) 
+	{
+		return getPaletteSize() == 1 && getBlockValueFromPaletteId(0) == blockValue;
+	}
+	
+	@Override
+	public int getUniqueBlockValuesCount() 
+	{
+		return getPaletteSize();
+	}
+	
+	public int getPaletteSize() 
+	{
+		return paletteSize;
+	}
+
+	public void setLayer(int yLevel, IBlockLayer<T> layer) 
+	{
+		if(layer instanceof IBlockSingleLayer<T> single) 
+		{
+			var blockValue = single.getBlockValue();
+			if(!paletteHasValue(blockValue)) 
+			{
+				addToPalette(blockValue);
+			}
+		}
+		layers[yLevel] = layer;
+	}
+
+	public IBlockLayer<T> getLayer(int yLevel) 
+	{
+		return layers[yLevel];
+	}
+	
+	@Override
+	public int getBlockValueID(T blockValue) 
+	{
+		final int paletteSize = getPaletteSize();
+		for(int i = 0; i < paletteSize; i++) 
+		{
+			if(blockStatePalette[i] == blockValue) 
+			{
+				return i;
+			}
+		}
 		return -1;
 	}
-
-	public int getBlockValueIDAddIfMissing(T blockValue) {
-		int i = this.getPaletteSize();
-
-		for (int j = 0; j < i; j++) {
-			if (this.blockStatePalette[j] == blockValue) {
-				return j;
+	
+	public int getBlockValueIDAddIfMissing(T blockValue) 
+	{
+		final int paletteSize = getPaletteSize();
+		for(int i = 0; i < paletteSize; i++) 
+		{
+			if(blockStatePalette[i] == blockValue) 
+			{
+				return i;
 			}
 		}
-
-		int k = this.getPaletteSize();
-		this.addToPalette(blockValue);
-		return k;
-	}
-
-	@Override
-	public T getBlockValueFromPaletteId(int bId) {
-		return this.blockStatePalette[bId];
-	}
-
-	public void addToPalette(T blockValue) {
-		if (this.paletteSize == this.blockStatePalette.length) {
-			int i = (int)((float)this.paletteSize * 1.75F);
-			i = Math.max(i, this.paletteSize + 1);
-			this.blockStatePalette = (T[])Arrays.copyOf(this.blockStatePalette, i);
-		}
-
-		this.blockStatePalette[this.paletteSize] = blockValue;
-		this.paletteSize++;
-	}
-
-	public boolean paletteHasValue(T blockValue) {
-		return this.getBlockValueID(blockValue) != -1;
-	}
-
-	@Override
-	public int getSaveFileConstant() {
-		return 2;
-	}
-
-	@Override
-	public void writeTo(IChunkByteWriter allChunksWriter) {
-		int i = this.getPaletteSize();
-		allChunksWriter.writeInt(i);
-
-		for (int j = 0; j < i; j++) {
-			allChunksWriter.writeBlockValue(this.getBlockValueFromPaletteId(j));
-		}
-
-		for (IBlockLayer<T> iblocklayer : this.getLayers()) {
-			allChunksWriter.writeByte(iblocklayer.getSaveFileConstant(this));
-			iblocklayer.writeTo(this, allChunksWriter);
-		}
-	}
-
-	public void cleanPalette() {
-		int i = this.getPaletteSize();
-		if (this.allowCleaning && i != 1) {
-			LayeredBlockData<T> layeredblockdata = new LayeredBlockData<>(this.getBlockValue(0, 0, 0));
-			layeredblockdata.allowCleaning = false;
-
-			for (int j = 0; j < 16; j++) {
-				if (this.getLayer(j) instanceof IBlockSingleLayer<T> iblocksinglelayer) {
-					layeredblockdata.setLayer(j, SharedBlockSingleLayer.get(layeredblockdata, iblocksinglelayer.getBlockValue()));
-				} else {
-					for (int k = 0; k < 16; k++) {
-						for (int l = 0; l < 16; l++) {
-							T t = this.getBlockValue(k, j, l);
-							layeredblockdata.setBlockValue(t, k, j, l);
-						}
+		int newPaletteID = getPaletteSize();
+		addToPalette(blockValue);
+		return newPaletteID;
+	}
+	
+	@Override
+	public T getBlockValueFromPaletteId(int bId) 
+	{
+		return blockStatePalette[bId];
+	}
+	
+	public void addToPalette(T blockValue) 
+	{
+		if(paletteSize == blockStatePalette.length) 
+		{
+			int newSize = (int)(paletteSize*1.75f);
+			newSize = Math.max(newSize, paletteSize+1);
+			blockStatePalette = Arrays.copyOf(blockStatePalette, newSize);
+		}
+		blockStatePalette[paletteSize] = blockValue;
+		paletteSize++;
+	}
+	public boolean paletteHasValue(T blockValue) 
+	{
+		return getBlockValueID(blockValue) != -1;
+	}
+
+	@Override
+	public int getSaveFileConstant() 
+	{
+		return SaveFileConstants.BLOCK_LAYERED;
+	}
+	
+	@Override
+	public void writeTo(IChunkByteWriter allChunksWriter) 
+	{
+		// Write the palette of the layered block data
+		int paletteSize = getPaletteSize();
+		allChunksWriter.writeInt(paletteSize);
+		for(int i = 0; i < paletteSize; i++) 
+		{
+			allChunksWriter.writeBlockValue(getBlockValueFromPaletteId(i));
+		}
+		
+		// Then write for the individual layers...
+		for(var layer : getLayers())
+		{
+			allChunksWriter.writeByte(layer.getSaveFileConstant(this));
+			layer.writeTo(this, allChunksWriter);
+		}
+	}
+	public void cleanPalette() 
+	{
+		int currentPaletteSize = getPaletteSize();
+		if(!allowCleaning || currentPaletteSize == 1) 
+		{
+			// Prevents possible infinite recursions
+			// and early exits if there's only a single palette value
+			return;
+		}
+		
+		
+		LayeredBlockData<T> tempBlockData = new LayeredBlockData<>(getBlockValue(0, 0, 0));
+		tempBlockData.allowCleaning  = false;
+		
+		for(int j = 0; j < CHUNK_WIDTH; j++) 
+		{
+			var layer = getLayer(j);
+			if(layer instanceof IBlockSingleLayer<T> singleLayer) 
+			{
+				tempBlockData.setLayer(j, SharedBlockSingleLayer.get(tempBlockData, singleLayer.getBlockValue()));
+			}else 
+			{		
+				for(int i = 0; i < CHUNK_WIDTH; i++) 
+				{
+					for(int k = 0; k < CHUNK_WIDTH; k++) 
+					{
+						var curBlockValue = getBlockValue(i, j, k);
+						tempBlockData.setBlockValue(curBlockValue, i, j, k);
 					}
 				}
 			}
-
-			this.paletteSize = layeredblockdata.paletteSize;
-			this.blockStatePalette = layeredblockdata.blockStatePalette;
-			this.layers = layeredblockdata.layers;
-			if (this.getPaletteSize() > 4096) {
-				throw new RuntimeException("Failed to clean palette: This should never happen.");
-			}
+		}		
+		
+		paletteSize = tempBlockData.paletteSize;
+		blockStatePalette = tempBlockData.blockStatePalette;
+		layers = tempBlockData.layers;
+		
+		if(getPaletteSize() > ISavedChunk.NUM_BLOCKS_IN_CHUNK) 
+		{
+			throw new RuntimeException("Failed to clean palette: This should never happen.");
 		}
 	}
-
-	public static <T> IBlockData<T> readFrom(IChunkByteReader reader, Function<String, T> saveKeyToBlockValue) throws IOException {
-		int i = reader.readInt();
-		LayeredBlockData<T> layeredblockdata = new LayeredBlockData<>(i);
-
-		for (int j = 0; j < i; j++) {
-			String s = reader.readString();
-			layeredblockdata.addToPalette(saveKeyToBlockValue.apply(s));
-		}
-
-		for (int k = 0; k < 16; k++) {
-			int l = reader.readByte();
-			switch (l) {
-				case 1:
-					int j1 = reader.readByte();
-					SharedBlockSingleLayer<T> sharedblocksinglelayer1 = SharedBlockSingleLayer.get(layeredblockdata, layeredblockdata.getBlockValueFromPaletteId(j1));
-					layeredblockdata.setLayer(k, sharedblocksinglelayer1);
-					break;
-				case 2:
-					int i1 = reader.readByte();
-					SharedBlockSingleLayer<T> sharedblocksinglelayer = SharedBlockSingleLayer.get(layeredblockdata, layeredblockdata.getBlockValueFromPaletteId(i1));
-					layeredblockdata.setLayer(k, sharedblocksinglelayer);
-					break;
-				case 3:
-					byte[] abyte3 = new byte[64];
-					reader.readFully(abyte3);
-					BlockHalfNibbleLayer<T> blockhalfnibblelayer = new BlockHalfNibbleLayer<>(abyte3);
-					layeredblockdata.setLayer(k, blockhalfnibblelayer);
-					break;
-				case 4:
-					byte[] abyte2 = new byte[128];
-					reader.readFully(abyte2);
-					BlockNibbleLayer<T> blocknibblelayer = new BlockNibbleLayer<>(abyte2);
-					layeredblockdata.setLayer(k, blocknibblelayer);
-					break;
-				case 5:
-					byte[] abyte1 = new byte[256];
-					reader.readFully(abyte1);
-					BlockByteLayer<T> blockbytelayer = new BlockByteLayer<>(abyte1);
-					layeredblockdata.setLayer(k, blockbytelayer);
-					break;
-				case 6:
-					BlockShortLayer<T> blockshortlayer = BlockShortLayer.readFrom(reader);
-					layeredblockdata.setLayer(k, blockshortlayer);
-					break;
-				case 7:
-					byte[] abyte = new byte[32];
-					reader.readFully(abyte);
-					BlockBitLayer<T> blockbitlayer = new BlockBitLayer<>(abyte);
-					layeredblockdata.setLayer(k, blockbitlayer);
-					break;
-				default:
-					throw new RuntimeException("Unknown layerType: " + l);
-			}
-		}
-
-		return layeredblockdata;
+	
+	public static <T> IBlockData<T> readFrom(IChunkByteReader reader, Function<String, T> saveKeyToBlockValue) throws IOException 
+	{
+		int paletteSize = reader.readInt();
+		final var chunkData = new LayeredBlockData<T>(paletteSize);
+		
+		for(int i = 0; i < paletteSize; i++) 
+		{
+			String blockStateSaveKey = reader.readString();
+			chunkData.addToPalette(saveKeyToBlockValue.apply(blockStateSaveKey));
+		}
+		for(int l = 0; l < CHUNK_WIDTH; l++) 
+		{
+			int layerType = reader.readByte();
+			
+			switch(layerType) 
+			{
+			case SaveFileConstants.BLOCK_LAYER_SINGLE_BYTE:
+			{
+				int blockId = reader.readByte();
+				var layer = SharedBlockSingleLayer.get(chunkData, chunkData.getBlockValueFromPaletteId(blockId));
+				chunkData.setLayer(l, layer);
+				break;
+			}
+			case SaveFileConstants.BLOCK_LAYER_SINGLE_INT:
+			{
+				int blockId = reader.readByte();
+				var layer = SharedBlockSingleLayer.get(chunkData, chunkData.getBlockValueFromPaletteId(blockId));
+				chunkData.setLayer(l, layer);
+				break;
+			}
+			case SaveFileConstants.BLOCK_LAYER_BIT:
+			{
+				byte[] bytes = new byte[CHUNK_WIDTH * CHUNK_WIDTH / 8];
+				reader.readFully(bytes);
+				var layer = new BlockBitLayer<T>(bytes);
+				chunkData.setLayer(l, layer);
+				break;
+			}
+			case SaveFileConstants.BLOCK_LAYER_HALFNIBBLE:
+			{
+				byte[] bytes = new byte[CHUNK_WIDTH * CHUNK_WIDTH / 4];
+				reader.readFully(bytes);
+				var layer = new BlockHalfNibbleLayer<T>(bytes);
+				chunkData.setLayer(l, layer);
+				break;
+			}
+			case SaveFileConstants.BLOCK_LAYER_NIBBLE:
+			{
+				byte[] bytes = new byte[CHUNK_WIDTH * CHUNK_WIDTH / 2];
+				reader.readFully(bytes);
+				var layer = new BlockNibbleLayer<T>(bytes);
+				chunkData.setLayer(l, layer);
+				break;
+			}
+			case SaveFileConstants.BLOCK_LAYER_BYTE:
+			{
+				byte[] bytes = new byte[CHUNK_WIDTH * CHUNK_WIDTH];
+				reader.readFully(bytes);
+				var layer = new BlockByteLayer<T>(bytes);
+				chunkData.setLayer(l, layer);
+				break;
+			}
+			case SaveFileConstants.BLOCK_LAYER_SHORT:
+			{
+				BlockShortLayer<T> layer = BlockShortLayer.readFrom(reader);
+				chunkData.setLayer(l, layer);
+				break;
+			}
+			default:
+				throw new RuntimeException("Unknown layerType: " + layerType);
+			}
+		}
+		return chunkData;
 	}
 }
